<!-- <script>
    var obj={
        a:1,
        fn:(function(val){
            // 赋给fn的是自执行函数的执行结果
            // 也就是一个undefined，是a of undefined 即obj是undefined
            // 该自执行函数只会执行一次
            console.log(val)
        })(obj.a)
    }
</script> -->
<!-- <script>
    let a=3;
    let b=new Number(3);
    let c=3;
    console.log(a==b);//true
    console.log(a===b);//false
    console.log(b===c);//false
    console.log(typeof(a));//number
    // typeof得到的是元素属于哪种数据类型
    console.log(typeof(b));//object
    // instanceof是判断某一个元素是否属于哪种数据类型，返回值是true或false
    console.log( b instanceof String)
</script>
 -->
<!-- <script>
    // 函数作用域中定义的变量，只能在函数中调用，外界是无法访问的。
    // 没有块级作用域导致了if或for这样的逻辑语句中定义的变量可以被外界访问
    for(var i=0;i<3;i++){
        setTimeout(()=>console.log(i),1);
    }
    //在一个函数中var的变量会进行变量提升，setTimeout是个异步操作
    //
    for(let i=0;i<3;i++){
        setTimeout(()=>console.log(i),1);
    }
</script> -->
<!-- ====JS的异步编程===== -->
<!-- 这个题目考查的是1）调用栈2）事件循环3）任务队列4）Promise的回调函数执行
5）async表达式的返回值 6）await表达式的作用和返回值
-->
<!-- <script>
    // MDN是这样描述await的：
    // async函数中可能会有await表达式，这样会使async函数暂停执行，
    // 等表达式中的Promise解析完成后继续执行async函数并返回解决结果。
    // 阮一峰老师的解释是：
    // async函数返回一个Promise对象，当函数执行的时候，一旦遇到await
    // 就会先返回，等到触发的异步操作完成，在接着执行函数体内后面的语句。
    async function async1() {
        console.log("async1 start")
        // 当await操作符后面的表达式是一个promise的时候，
        // 它的返回值，实际上就是Promise的回调函数resolve的参数
        await async2();
        console.log('async1 end')
    }
    // async表达式定义的函数也是立即执行的
    async function async2() {
        console.log('async2');
    }
    // async1();
    console.log("script start");
    // 以第二个参数是0的方式调用setTimeout就是推迟到调用栈为空才执行回调。
    setTimeout(function () {
        console.log("settimeout");
    }, 0)
    // 如果async1()放在console.log("script start")之前
    // 运行的结果就是async1 start，async2，script start
    // async表达式定义的函数也是立即执行的
    async1();
    //Promise是一个立即执行函数，但是它的成功（或失败：reject）
    // 的回调函数resolve却是一个异步执行的回调。
    new Promise(function (resolve) {
        console.log("promise1")
        // 当执行到resolve()时，这个任务会被放到回调队列
        // 中，等待调用栈有空闲时事件循环再来取走它
        resolve();
        // 如果为真就执行resolve()
    }).then(function () {
        console.log("promise2");
    });
    console.log('script end')
// JS复习.html:46 script start
// JS复习.html:39 async1 start
// JS复习.html:44 async2
// JS复习.html:53 promise1
// JS复习.html:58 script end
// JS复习.html:41 async1 end
// JS复习.html:56 promise2
// JS复习.html:49 settimeout
// 首先，事件循环从宏任务（macrostack）队列开始，这个时候，宏任务队列中，只有一个 script (整体代码)任务。从宏任务队列中取出一个任务来执行。
// 首先执行 console.log('script start')，输出 ‘script start'
// 遇到 setTimeout 把 console.log('setTimeout') 放到 macrotask 队列中
// 执行 aync1() 输出 ‘async1 start' 和 'async2' ,把 console.log('async1 end') 放到 micro 队列中
// 执行到 promise ，输出 'promise1' ，把 console.log('promise2') 放到  micro 队列中
// 执行 console.log('script end')，输出 ‘script end'
// macrotask 执行完成会执行 microtask ，把 microtask quene 里面的 microtask 全部拿出来一次性执行完，所以会输出 'async1 end' 和 ‘promise2'
// 开始新一轮的事件循环，去除执行一个 macrotask 执行，所以会输出 ‘setTimeout'
// 原文链接：https://blog.csdn.net/MFWSCQ/article/details/105109727
</script> -->
<!-- Promise的简单使用 -->
<!-- Promise对象有三种状态，他们分别是：
pending: 等待中，或者进行中，表示还没有得到结果
resolved(Fulfilled): 已经完成，表示得到了我们想要的结果，可以继续往下执行
rejected: 也表示得到结果，但是由于结果并非我们所愿，因此拒绝执行
这三种状态不受外界影响，而且状态只能从pending改变为resolved或者rejected，并且不可逆。
在Promise对象的构造函数中，将一个函数作为第一个参数。
而这个函数，就是用来处理Promise的状态变化。
上面的resolve和reject都为一个函数，他们的作用分别是将状态修改为resolved和rejected。

链接：https://www.jianshu.com/p/fe5f173276bd -->
<!-- <script>
    function fn(num) {
    return new Promise(function(resolve, reject) {
        if (typeof num == 'number') {
            resolve();
        } else {
            reject();
        }
    }).then(function() {
        console.log('参数是一个number值');
    }, function() {
        console.log('参数不是一个number值');
    })
}
//Promise对象中的then方法，可以接收构造函数中处理的状态变化，并分别对应执行。
//then方法有2个参数，第一个函数接收resolved状态的执行，第二个参数接收reject状态的执行。
fn('hahha');//参数不是一个number值
fn(1234);//参数是一个number值
// then方法的执行结果也会返回一个Promise对象
</script> -->
<!-- <script>
    function fn(num) {
    return new Promise(function(resolve, reject) {
        if (typeof num == 'number') {
            resolve();
        } else {
            reject();
        }
    })
    .then(function() {
        console.log('参数是一个number值');
    })
    .then(null, function() {
        console.log('参数不是一个number值');
    })
}
// then(null, function() {}) 就等同于catch(function() {})
fn('hahha');
fn(1234);
</script> -->
<!-- <script>
    var a = 20;
    function foo() {
        if (!a) {
            a = 100;
        }
        var a = 10;
        return a;
    }
    console.log(foo());
</script> -->
<!--====对比较运算符==的简单应用========= -->
<script>
    /*  var undefined;
     console.log(undefined==null)
     console.log(1==true)
     console.log(2==true)
     console.log(0==false)
     console.log(0=="")
     console.log(NaN==NaN)
     console.log([]==false)
     console.log([]==![]); */
    // 如果对字符串只是进行简单的+，就是字符串的拼接
    // 其类型依旧是string
    /* var f1="11"+2
    console.log(f1)
    console.log(typeof f1)
    // 当字符串有-出现的时候，其类型也变成了number
    // 如果字符串都是数字，会返回一个运算后的数字
    // 如果不是就返回NaN，类型依旧是number
    var foo="11"+3-"1"
    console.log(foo)
    console.log(typeof foo) */
</script>
<!-- =====JS中join方法和split方法===== -->
<script>
    /* var stringArray=["this","is","baidu"];
    // 方法join()是可以让数组的值拼接成字符串
    // 如果直接使用join不写参数的话结果直接是
    console.log(stringArray.join());//this,is,baidu
    // 写一个空串，没有空格
    console.log(stringArray.join(""))//thisisbaidu
    //带有空格结果就是带有空格的形式
    console.log(stringArray.join(" "))
    // 在双引号中，可以写上任意的字符串
    console.log(stringArray.join("=")) */
    /* function comb(msg){
        // 方法split把字符串通过-的方式分割成数组
        var arr=msg.split("-");
        console.log(arr)//["element", "by", "id"]
        for(var i=0;i<arr.length;i++){
            arr[i]=arr[i].charAt(0).toUpperCase()+arr[i].substr(1,arr[i].length-1)
        }
        // charAt(index) 方法可返回指定位置的字符。
        // index必需.表示字符串中某个位置的数字，即字符在字符串中的下标。
        // toUpperCase() 方法用于把字符串转换为大写。
        // stringObject.substr(start,length)
        // substr() 方法可在字符串中抽取从 start 下标开始的指定数目的字符。
        msg=arr.join("");
        return msg
    }
 const result=comb("element-by-id")
 console.log(result) */
</script>
<!-- ===替换掉需要更改的值，使用正则表达式，replace=== -->
<script>
    /* function escapeHtml(str){
        return str.replace(/[<>"&]/g,function(match){
            switch(match){
                case "<":return "是个";
                case ">":return "&gt;";
                case "&":return "&amp;";
                case "/":return '&quot;';
            }
        })
    }
   let result= escapeHtml("小明<希望>----<我们 & 喜欢&")
    console.log(result) */
</script>
<!-- 用js实现随机选取10-100之间的10个数字，存入一个数组，并排序 -->
<!-- <script>
    // 这个是递归调用
    function randomNub(aArray, len, min, max) {
        // 判断max和min之前是否存在len个数
        if (len >= (max - min)) {
            return "超过" + min + "-" + max + "之间的个数范围" + (max - min - 1) + "个总数"
        }
        // 判断数组的长度
        if (aArray.length >= len) {
            // 将数组进行升序排列
            // aArray.sort()的返回值是一个数组
            // 放入函数，是一个升序排列的数组
            aArray.sort(function (a, b) {
                return a - b
            })
            // 返回这个数组
            return aArray
        }
        // 拿到随机数
        var nowNub = parseInt(Math.random() * (max - min - 1) + (min + 1));
        // console.log(nowNub)
        // console.log(aArray.length)
        // 判断数组长度，如果长度等于0，就不执行for循环
        for (var j = 0; j < aArray.length; j++) {
            // 看看随机数是否和数组中之前的元素相同 
            if (nowNub == aArray[j]) {
                // 如果相同，就再次调用函数，注意调用的是整个函数
                // 但是整个函数是有返回值的，所以调用这个函数就会返回一个aArray
                randomNub(aArray, len, min, max)
                // 如果不return的话，就会出现重复的数，并且数组的长度会增加
                return
            }
        }
        // push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。
        // 注意： 新元素将添加在数组的末尾。
        // 注意： 此方法改变数组的长度。
        // 提示： 在数组起始位置添加元素请使用 unshift() 方法。
        // 把拿到的随机数push到aArray数组中
        aArray.push(nowNub);
        randomNub(aArray, len, min, max);
        return aArray
    }
    var arr = [];
    var result = randomNub(arr, 10, 10, 100)
    console.log(result)
</script> -->
<!--
解析：
    第一步：调用这个方法，需要传递4个参数，aArray一个数组，len是数组的长度，min是数组的最小值，max是数组中的最大值
    第二步：判断所传数组的长度是否小于自己所选的max-min长度（小于说明自己传入的参数合适，需要传入新的参数）
    第三步：判断数组长度，如果长度大于等于len就返回一个升序排列的数组
    第四步：拿到随机数
    第五步：判断数组长度，如果长度等于0，就不执行for循环；
    如果长度不为0，判断拿到的随机数与数组中的数据是否有相同的，有的话就进行递归调用
       -->
<!-- <script>
    var array1=["a","b","c"];
    var barr=["d","e"];
    // 合并两个数组
    var carr=array1.concat(barr)
    console.log(carr)
    // 删除数组中的第二个元素
    carr.splice(1,1)
    console.log(carr)
</script> -->
<script>
    // 提取URL中的各个GET参数(参数名和参数个数不确定)，
    // 将其按key-value形式返回到一个json结构中
    function serilizeUrl(url){
        var urlObject={};
        if(/\?/.test(url)){
            var urlString=url.substring(url.indexOf("?")+1);
            var urlArray=urlString.split("&");
            for(var i=0,len=urlArray.length;i<len;i++){
                var urlItem=urlArray[i];
                var item=urlItem.split("=");
                urlObject[item[0]]=item[1];
            }
            return urlObject
        }
        return null
    }
   let result= serilizeUrl("http://item.taobao.com/item.htm?a=1&b=2&c=&d=xxx&e")
   console.log(result)
//    {a: "1", b: "2", c: "", d: "xxx", e: undefined}
</script>


