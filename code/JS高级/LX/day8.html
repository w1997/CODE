<!-- <script>
    (function(){
        var a=1;
        var obj={
            a:10,
            f:function(){
                a*=2;
            }
        }
        obj.f()
        alert(obj.a+a)
    })();
</script> -->
<!-- <script>
    window.a=1;
    var obj={
        a:10,
        f:function(){
            this.a*=2;
            console.log(this.a)
        }
    }
    obj.f()
</script> -->
<!-- <script>
    var fullName="la";
var obj={
    fullName:"js",
    prop:{
        // fullName:"vue",
        getFullName:function(){
            return this.fullName;
        }
    }
}
// console.log(obj.prop.getFullName())
var t=obj.prop.getFullName;
console.log(t())
</script> -->
<!-- <script>
    let obj={
        fn:(function(){
            return function(){
                console.log(this)
            }
        })()
    }
   let t= obj.fn
   t()
</script> -->
<!-- <script>
    var a = 20;

function foo() {
  if (!a) {
    a = 100;
  }

  var a = 10;

  return a;
}

console.log(foo());
</script> -->
<!-- <script>
    function fn(){
	return 20;
}
console.log(fn);//ƒ fn(){return 20;}
console.log(fn+10);//function fn(){return 20;}10
fn.toString = function(){
	return 10;
}
console.log(fn); //结果是f 10
console.log(fn+10); //结果是20
</script> -->
<!-- <script>
    setTimeout(function () {
  console.log(a);
}, 0);

var a = 10;

console.log(b);
console.log(fn);

var b = 20;

function fn() {
  setTimeout(function () {
    console.log('setTImeout 10ms.');
  }, 10);
}

fn.toString = function () {
  return 30;
}

console.log(fn);

setTimeout(function () {
  console.log('setTimeout 20ms.');
}, 20);

fn();
</script> -->
<!-- =====this的指向问题==== -->
<!-- <script>
    var a = 20;
function foo() {
  var a = 1;
  var obj = {
    a: 10,
    c: this.a + 20,
    fn: function () {
      return this.a;
    }
  }
  return obj.c;
}
console.log(foo());    // 40
console.log(window.foo());  // 40
</script> -->
<!-- <script>
    function foo() {
  console.log(this.a)
}

function active(fn) {
  fn(); // 真实调用者，为独立调用
}

var a = 20;
// 单独的{}不会形成新的作用域，
// 因此这里的this.a，由于并没有作用域的限制，它仍然处于全局作用域之中。
// 所以这里的this其实是指向的window对象。
var obj = {
  a: 10,
  getA: foo
}
// obj.getA并没有调用getA方法
console.log(obj.getA);// function foo() { console.log(this.a)}
active(obj.getA);//结果是20
</script> -->
<script>
    // demo05
(function () {

var a = 10;
var b = 20;

var test = {
  m: 20,
  add: function (x) {
    return a + x;
  },
  sum: function () {
    return a + b + this.m;
  },
  mark: function (k, j) {
    return k + j;
  }
}

window.test = test;

})();

test.add(100);
test.sum();
test.mark();

var _mark = test.mark;
_mark();
</script>


