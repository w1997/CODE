<!-- <script>
    (function(){
        var a=1;
        var obj={
            a:10,
            f:function(){
                a*=2;
            }
        }
        obj.f()
        alert(obj.a+a)
    })();
</script> -->
<!-- <script>
    window.a=1;
    var obj={
        a:10,
        f:function(){
            this.a*=2;
            console.log(this.a)
        }
    }
    obj.f()
</script> -->
<!-- <script>
    var fullName="la";
var obj={
    fullName:"js",
    prop:{
        // fullName:"vue",
        getFullName:function(){
            return this.fullName;
        }
    }
}
// console.log(obj.prop.getFullName())
var t=obj.prop.getFullName;
console.log(t())
</script> -->
<!-- <script>
    let obj={
        fn:(function(){
            return function(){
                console.log(this)
            }
        })()
    }
   let t= obj.fn
   t()
</script> -->
<!-- <script>
    var a = 20;

function foo() {
  if (!a) {
    a = 100;
  }

  var a = 10;

  return a;
}

console.log(foo());
</script> -->
<!-- <script>
    function fn(){
	return 20;
}
console.log(fn);//ƒ fn(){return 20;}
console.log(fn+10);//function fn(){return 20;}10
fn.toString = function(){
	return 10;
}
console.log(fn); //结果是f 10
console.log(fn+10); //结果是20
</script> -->
<!-- <script>
    setTimeout(function () {
  console.log(a);
}, 0);

var a = 10;

console.log(b);
console.log(fn);

var b = 20;

function fn() {
  setTimeout(function () {
    console.log('setTImeout 10ms.');
  }, 10);
}

fn.toString = function () {
  return 30;
}

console.log(fn);

setTimeout(function () {
  console.log('setTimeout 20ms.');
}, 20);

fn();
</script> -->
<!-- =====this的指向问题==== -->
<!-- <script>
    var a = 20;
function foo() {
  var a = 1;
  var obj = {
    a: 10,
    c: this.a + 20,
    fn: function () {
      return this.a;
    }
  }
  return obj.c;
}
console.log(foo());    // 40
console.log(window.foo());  // 40
</script> -->
<!-- <script>
    function foo() {
  console.log(this.a)
}

function active(fn) {
  fn(); // 真实调用者，为独立调用
}

var a = 20;
// 单独的{}不会形成新的作用域，
// 因此这里的this.a，由于并没有作用域的限制，它仍然处于全局作用域之中。
// 所以这里的this其实是指向的window对象。
var obj = {
  a: 10,
  getA: foo
}
// obj.getA并没有调用getA方法
console.log(obj.getA);// function foo() { console.log(this.a)}
active(obj.getA);//结果是20
</script> -->
<!-- ============利用断点，查看闭包 -->
<!-- <script>
  // demo05
  (function () {

    var a = 10;
    var b = 20;

    var test = {
      m: 20,
      add: function (x) {
        return a + x;
      },
      sum: function () {
        return a + b + this.m;
      },
      mark: function (k, j) {
        return k + j;
      }
    }

    window.test = test;

  })();

  test.add(100);
  test.sum();
  test.mark();

  var _mark = test.mark;
  _mark();
</script> -->
<!-- <script>
  function foo() {
    console.log(this.a)
  }

  function active(fn) {
    fn(); // 真实调用者，为独立调用
  }

  var a = 20;
  var obj = {
    a: 10,
    getA: foo
  }

  active(obj.getA);//20
</script> -->
<!-- <script>
  function exam(a, b, c, d, e) {

    // 先看看函数的自带属性 arguments 什么是样子的
    console.log(arguments);

    // 使用call/apply将arguments转换为数组, 返回结果为数组，arguments自身不会改变
    var arg = [].slice.call(arguments);

    console.log(arg);
  }

  exam(2, 8, 9, 10, 3);

// result:
// { '0': 2, '1': 8, '2': 9, '3': 10, '4': 3 }
// [ 2, 8, 9, 10, 3 ]
//
// 也常常使用该方法将DOM中的nodelist转换为数组
// [].slice.call( document.getElementsByTagName('li') );
</script> -->
<!-- =======函数参数传递方式：按值传递-->
<script>
  /* var a = 20;

  function fn(a) {
    a = a + 10;
    console.log(a)
  }
  fn(a);
  console.log(a); // 20 */
  /* var a = { m: 10, n: 20 }
  function fn(a) {
    a.m = 20;
    console.log(a)
  }

  fn(a);
  console.log(a);   // { m: 20, n: 20 } */
  var person = {
    name: 'Nicholas',
    age: 20
  }

  function setName(obj) {  // 传入一个引用
    obj = {};   // 将传入的引用指向另外的值
    obj.name = 'Greg';  // 修改引用的name属性
  }

  setName(person);
  console.log(person.name);  // Nicholas 未被改变
  // 如果person是按引用传递，那么person就会自动被修改为指向其name属性值为Gerg的新对象。
  // 但是我们从结果中看到，person对象并未发生任何改变，因此只是在函数内部引用被修改而已。
</script>